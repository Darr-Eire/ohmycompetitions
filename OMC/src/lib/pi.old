

/** Detect Pi Browser (guard for SSR) */
export const isPiBrowser = () =>
  typeof navigator !== 'undefined' && /PiBrowser/i.test(navigator.userAgent);

/** Wait until the Pi SDK is ready (createPayment present) */
async function waitForPi(maxMs = 6000) {
  const start = Date.now();
  while (Date.now() - start < maxMs) {
    if (typeof window !== 'undefined' && window.Pi && typeof window.Pi.createPayment === 'function') {
      return window.Pi;
    }
    await new Promise((r) => setTimeout(r, 200));
  }

  // Remove any existing SDK script
  const existingScript = document.querySelector('script[src*="pi-sdk.js"]');
  if (existingScript) {
    existingScript.remove();
  }

  const script = document.createElement('script');
  script.src = 'https://sdk.minepi.com/pi-sdk.js';
  script.async = true;
  let checkTimeout;

  script.onload = () => {
    // Clear any existing check timeout
    if (checkTimeout) {
      clearTimeout(checkTimeout);
    }

    const check = setInterval(() => {
      if (window.Pi && typeof window.Pi.createPayment === 'function') {
        clearInterval(check);
        clearTimeout(checkTimeout);

        const sandbox = process.env.NEXT_PUBLIC_PI_SANDBOX === 'true';
        try {
          window.Pi.init({ version: '2.0', sandbox, appId: process.env.NEXT_PUBLIC_PI_APP_ID, scopes: ['username', 'payments'] });
          setReady(true);
          console.log('✅ Pi SDK loaded and initialized in', sandbox ? 'sandbox' : 'production', 'mode');
        } catch (err) {
          console.error('❌ Failed to initialize Pi SDK:', err);
          setReady(false);
        }
      }
    }, 100);

    // Set a timeout to stop checking after 10 seconds
    checkTimeout = setTimeout(() => {
      clearInterval(check);
      console.error('❌ Pi SDK initialization timed out');
      setReady(false);
    }, 10000);
  };

  script.onerror = (error) => {
    console.error('❌ Failed to load Pi SDK:', error);
    setReady(false);
  };

  document.body.appendChild(script);

  throw new Error('Pi SDK not available yet');

}

/** Base URL helper (use relative in prod; allow ngrok in dev) */
function getBaseUrl() {
  if (typeof window === 'undefined') return '';
  if (window.location.origin.includes('ngrok')) return window.location.origin;
  return ''; // same-origin
}

/** Create a Pi payment for a competition entry */
export async function createPiPayment({ competitionSlug, amount, memo }) {
  const Pi = await waitForPi();

  return new Promise((resolve, reject) => {
    const paymentData = {
      amount: Number(parseFloat(amount).toFixed(2)),
      memo: memo || `Competition entry: ${competitionSlug}`,
      metadata: { type: 'competition_entry', competitionSlug, timestamp: Date.now() },
    };

    Pi.createPayment(paymentData, {
      onReadyForServerApproval: async (paymentId) => {
        try {
          const res = await fetch(`${getBaseUrl()}/api/pi/approve-payment`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              paymentId,
              slug: competitionSlug,
              amount: paymentData.amount,
            }),
          });
          if (!res.ok) {
            const text = await res.text();
            console.error('Approval failed:', res.status, text);
            // Let the SDK continue; do not reject here.
          }
        } catch (err) {
          console.error('Approval error:', err);
          // Let the SDK continue; do not reject here.
        }
      },

      onReadyForServerCompletion: async (paymentId, txid) => {
        try {
          const res = await fetch(`${getBaseUrl()}/api/pi/complete-payment`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              paymentId,
              txid,
              slug: competitionSlug,
              amount: paymentData.amount,
            }),
          });
          if (!res.ok) throw new Error(await res.text());
          resolve(await res.json());
        } catch (err) {
          console.error('Completion error:', err);
          reject(err);
        }
      },

      onCancel: (paymentId) => reject(new Error('Payment cancelled: ' + paymentId)),
      onError: (error, payment) =>
        reject(error instanceof Error ? error : new Error('Payment error')),
    });
  });
}

/** Handle incomplete payments (call from Pi.authenticate callback) */
export async function handleIncompletePayment(payment, competitionSlug) {
  const res = await fetch(`${getBaseUrl()}/api/pi/incomplete`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ payment, slug: competitionSlug || null }),
  });
  return res.json().catch(() => ({}));
}
