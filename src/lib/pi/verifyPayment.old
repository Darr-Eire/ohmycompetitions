// src/lib/pi/verifyPayment.js
// Server-side helper to verify/approve/complete a Pi payment.
// Uses unified helpers from src/lib/piClient.js

import {
  getPayment as apiGetPayment,
  approvePayment as apiApprovePayment,
  completePayment as apiCompletePayment,
  pollPaymentUntilFound,
} from '../piClient';

const TOLERANCE = 0.01; // π amount tolerance

/* ----------------------------- Thin wrappers ----------------------------- */
// All server API calls require the user's accessToken.
export async function getPayment(paymentId, accessToken) {
  return apiGetPayment(paymentId, accessToken);
}

export async function approvePayment(paymentId, accessToken) {
  return apiApprovePayment(paymentId, accessToken);
}

export async function completePayment(paymentId, txid, accessToken) {
  return apiCompletePayment(paymentId, txid, accessToken);
}

/* ------------------------------ Main verify ------------------------------ */
/**
 * Verify/approve/complete a Pi payment and return a normalized result.
 *
 * @param {Object} params
 * @param {string} params.paymentId           Required Pi payment identifier
 * @param {string} params.accessToken         Required access token from Pi.authenticate()
 * @param {number} [params.expectedAmount]    Optional π amount to validate (± TOLERANCE)
 * @param {string} [params.username]          Optional expected user match (username or uid)
 * @param {string} [params.txid]              Optional blockchain txid (if already known)
 * @param {string} [params.reason='generic']  Optional reason label for logging
 * @param {boolean} [params.poll=true]        Poll for existence first (fixes 404 race)
 * @param {number} [params.pollAttempts=8]    Poll attempts
 * @param {number} [params.pollDelayMs=1500]  Delay between polls (ms)
 */
export async function verifyPayment({
  paymentId,
  accessToken,
  expectedAmount,
  username,
  txid,
  reason = 'generic',
  poll = true,
  pollAttempts = 8,
  pollDelayMs = 1500,
}) {
  if (!paymentId) return { ok: false, error: 'Missing paymentId' };
  if (!accessToken) return { ok: false, error: 'Missing accessToken' };

  try {
    // Handle the create→404 race by polling until the payment shows up.
    if (poll) {
      await pollPaymentUntilFound(paymentId, {
        accessToken,
        attempts: pollAttempts,
        delayMs: pollDelayMs,
      });
    }

    let p = await getPayment(paymentId, accessToken);

    // Optional user check
    if (username) {
      const u = p?.user || {};
      const matches = [u.username, u.uid].filter(Boolean).some((v) => String(v) === String(username));
      if (!matches) {
        return { ok: false, error: 'User mismatch', got: p?.user, expected: username };
      }
    }

    // Optional amount check
    if (typeof expectedAmount === 'number') {
      const same = Math.abs(Number(p.amount) - Number(expectedAmount)) <= TOLERANCE;
      if (!same) {
        return {
          ok: false,
          error: 'Amount mismatch',
          expectedAmount,
          onChainAmount: p.amount,
        };
      }
    }

    // Approve if not already developer-approved
    if (!p?.status?.developer_approved) {
      const a = await approvePayment(paymentId, accessToken);
      p.status = a.status || p.status;
    }

    // Complete if not already completed and we have a txid (or it’s already verified)
    const alreadyVerified = Boolean(p?.status?.transaction_verified || p?.transaction?.verified);
    if (!p?.status?.developer_completed) {
      const finalTxid = txid || p?.transaction?.txid || '';
      if (finalTxid || alreadyVerified) {
        const c = await completePayment(paymentId, finalTxid, accessToken);
        p.status = c.status || p.status;
      }
    }

    // Refresh state (optional but nice)
    p = await getPayment(paymentId, accessToken);

    const approved = Boolean(p?.status?.developer_approved);
    const completed = Boolean(p?.status?.developer_completed || p?.status?.transaction_verified);

    return {
      ok: approved, // treat approved as minimal success
      approved,
      completed,
      canonical: p, // full Pi payment object
      reason,
    };
  } catch (err) {
    const http = err?.response?.status;
    return {
      ok: false,
      error: err?.message || 'verifyPayment failed',
      http,
      details: err?.response?.data,
    };
  }
}

export default { getPayment, approvePayment, completePayment, verifyPayment };
