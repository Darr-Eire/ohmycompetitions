// lib/vouchers.js
import crypto from 'crypto';

// =======================
// Config / constants
// =======================
export const VOUCHER_PREFIX = process.env.VOUCHER_PREFIX || 'OMC';
// exclude easily-confused chars: I, O, 0, 1
export const VOUCHER_ALPHABET = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
export const VOUCHER_GROUP_LEN = 4;
export const VOUCHER_GROUPS = 3;

// secret used for hashing voucher codes (do NOT check this into git)
const SECRET = process.env.VOUCHER_SECRET || 'change-me';

// =======================
// Internals
// =======================

/** Secure random int in [0, max) */
function rand(max) {
  // crypto.randomInt is uniform and avoids modulo bias
  return crypto.randomInt(0, max);
}

/** Secure random string from ALPHABET */
function randomFromAlphabet(len, alphabet = VOUCHER_ALPHABET) {
  let out = '';
  for (let i = 0; i < len; i++) out += alphabet[rand(alphabet.length)];
  return out;
}

/** Uppercase + trim + collapse whitespace */
export function normalizeCode(raw) {
  if (!raw) return '';
  return String(raw).toUpperCase().trim();
}

/** Re-hyphenate code to PREFIX-XXXX-XXXX-XXXX using current alphabet */
export function canonicalizeCode(raw, {
  prefix = VOUCHER_PREFIX,
  groupLen = VOUCHER_GROUP_LEN,
  groups = VOUCHER_GROUPS,
} = {}) {
  const s = normalizeCode(raw).replace(/[^A-Z0-9]/g, ''); // strip non-alnum
  const pref = normalizeCode(prefix).replace(/[^A-Z0-9]/g, '');
  const body = s.startsWith(pref) ? s.slice(pref.length) : s;
  const onlyBody = body.replace(/[^A-Z0-9]/g, '');
  const chunks = [];
  for (let g = 0; g < groups; g++) {
    const start = g * groupLen;
    chunks.push(onlyBody.slice(start, start + groupLen));
  }
  return `${pref}-${chunks.join('-')}`;
}

/** Validate code format against alphabet and grouping */
export function validateCodeFormat(code, {
  prefix = VOUCHER_PREFIX,
  groupLen = VOUCHER_GROUP_LEN,
  groups = VOUCHER_GROUPS,
  alphabet = VOUCHER_ALPHABET,
} = {}) {
  const chars = alphabet.replace(/[-\\^$*+?.()|[\]{}]/g, '\\$&');
  const re = new RegExp(
    `^${normalizeCode(prefix)}(?:-[${chars}]{${groupLen}}){${groups}}$`
  );
  return re.test(canonicalizeCode(code, { prefix, groupLen, groups }));
}

/** Hide most of the code for logs */
export function maskCode(code, revealGroupCount = 1) {
  const parts = canonicalizeCode(code).split('-');
  const head = parts.slice(0, -revealGroupCount).map((p, idx) => (idx === 0 ? p : '****'));
  const tail = parts.slice(-revealGroupCount);
  return [...head, ...tail].join('-');
}

// =======================
// Public API
// =======================

/**
 * Hash a voucher code using SHA-256 + secret. (Stable)
 * NOTE: If you already saved hashes generated by a previous method,
 * keep this function as-is for compatibility.
 */
export function hashCode(code) {
  const normalized = canonicalizeCode(code);
  // Use HMAC for better key handling; if you need strict compatibility
  // with a prior simple hash(`${code}:${SECRET}`), swap back accordingly.
  return crypto.createHmac('sha256', SECRET).update(normalized).digest('hex');
}

/** Generate a single human-friendly code: e.g. OMC-XXXX-XXXX-XXXX */
export function generateHumanCode({
  prefix = VOUCHER_PREFIX,
  groupLen = VOUCHER_GROUP_LEN,
  groups = VOUCHER_GROUPS,
  alphabet = VOUCHER_ALPHABET,
} = {}) {
  const chunks = [];
  for (let i = 0; i < groups; i++) chunks.push(randomFromAlphabet(groupLen, alphabet));
  return `${normalizeCode(prefix)}-${chunks.join('-')}`;
}

/** Generate { code, hash } pair (donâ€™t store plaintext in DB; give code to admin once) */
export function generateCodeAndHash(opts = {}) {
  const code = generateHumanCode(opts);
  const codeHash = hashCode(code);
  return { code, codeHash };
}

/** Generate a batch of pairs */
export function generateBatch(count = 1, opts = {}) {
  const out = [];
  for (let i = 0; i < count; i++) out.push(generateCodeAndHash(opts));
  return out;
}

/** Basic verification against a stored doc: { codeHash, expiresAt, maxRedemptions, redeemedCount } */
export function verifyCodeAgainstDoc(code, doc) {
  if (!doc) return { ok: false, error: 'Not found' };
  if (doc.expiresAt && new Date(doc.expiresAt) < new Date()) {
    return { ok: false, error: 'Expired' };
  }
  if (typeof doc.maxRedemptions === 'number' && typeof doc.redeemedCount === 'number') {
    if (doc.redeemedCount >= doc.maxRedemptions) {
      return { ok: false, error: 'Redemption limit reached' };
    }
  }
  const matches = hashCode(code) === doc.codeHash;
  return matches ? { ok: true } : { ok: false, error: 'Invalid code' };
}

/** Helper to build a document you can insert into your vouchers collection */
export function buildVoucherDoc({
  code,                     // plaintext to show only once (do not store)
  competitionSlug,
  ticketCount = 1,
  maxRedemptions = 1,
  perUserLimit = 1,
  assignedToUserId = null,
  notes = '',
  expiresAt = null,
}) {
  const normalized = canonicalizeCode(code);
  return {
    codeHash: hashCode(normalized),
    codeMasked: maskCode(normalized),
    competitionSlug,
    ticketCount,
    maxRedemptions,
    perUserLimit,
    assignedToUserId,
    notes,
    expiresAt: expiresAt ? new Date(expiresAt) : null,
    redeemedCount: 0,
    createdAt: new Date(),
    updatedAt: new Date(),
  };
}
